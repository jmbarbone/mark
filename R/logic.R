#' Logic - Extensions
#'
#' Logical operations, extended
#'
#' @description All functions take logical or logical-like (i.e., 1, 0, or NA as
#' integer or doubles) and return logical values.
#'
#' Extensions to the base logical operations to account for `NA` values.
#'
#' [base::isTRUE()] and [base::isFALSE()] will only return single length `TRUE`
#' or `FALSE` as it checks for valid lengths in the evaluation.  When needing to
#' check over a vector for the presence of `TRUE` or `FALSE` and not being held
#' back by `NA` values, `is_true` and `is_false` will always provide a `TRUE`
#' `FALSE` when the vector is logical or return `NA` is the vector `x` is not
#' logical.
#'
#' `%xor%` is just a wrapper for [base::xor()]
#'
#' @param x,y  A vector of values.  `%xor`, `nor`, `nand`, and `xnandr`
#' @param ... Vectors or a list of logical values
#' @param na.rm Logical, if `TRUE` will ignore `NA`
#'
#' @examples
#' x <- c(TRUE, FALSE, NA)
#' y <- c(FALSE, FALSE, TRUE)
#' z <- c(TRUE, NA, TRUE)
#' isTRUE(x)
#' is_true(x)
#' isFALSE(x)
#' is_false(x)
#' x %xor% TRUE
#' TRUE %xor% TRUE
#' TRUE %xor% FALSE
#' NA %xor% FALSE
#' OR(x, y, z)
#' OR(x, y, z, na.rm = TRUE)
#' AND(x, y, z)
#' AND(x, y, z, na.rm = TRUE)
#' either(x, FALSE)
#' either(TRUE, FALSE)
#' either(FALSE, NA)
#' either(TRUE, NA)
#' none(x)
#' none(x & y, na.rm = TRUE)
#' is_boolean(x)
#' is_boolean(c(1L, NA_integer_, 0L))
#' is_boolean(c(1.01, 0, -1))
#' @return
#' * `is_true()`, `is_false()`, `either()`, `%or%`, `nor`, `nand`, `xandr`,
#' `AND()`, `OR()`: A `logical` vector, equal length of `x` (or `y` or of all
#' `...` lengths)
#' * `is_boolean()`, `isNA()`, `none()`: A single `logical` value
#'
#' @name logic_ext
NULL

#' @export
#' @rdname logic_ext
is_true <- function(x) {
  UseMethod("is_true", x)
}

#' @export
#' @rdname logic_ext
is_true.default <- function(x) {
  rep(NA, length(x))
}

#' @export
#' @rdname logic_ext
is_true.logical <- function(x) {
  !is.na(x) & x
}

#' @export
#' @rdname logic_ext
is_false <- function(x) {
  UseMethod("is_false", x)
}

#' @export
#' @rdname logic_ext
is_false.default <- function(x) {
  rep(NA, length(x))
}

#' @export
#' @rdname logic_ext
is_false.logical <- function(x) {
  !is.na(x) & !x
}

# nocov start
#' @export
#' @rdname logic_ext
`%xor%` <- function(x, y) {
  # this wasn't ever needed
  .Deprecated(
    msg = "`%xor%` is deprecated. Please use `xor()` instead.",
    old = "%xor%"
  )
  xor(x, y)
}
# nocov end

#' @export
#' @rdname logic_ext
nor <- function(x, y) {
  !(x | y)
}

#' @export
#' @rdname logic_ext
nand <- function(x, y) {
  !(x & y)
}

#' @export
#' @rdname logic_ext
xnandr <- function(x, y) {
  (!x & !y) | (x & y)
}

#' @export
#' @rdname logic_ext
# nolint next: object_name_linter.
OR <- function(..., na.rm = FALSE) {
  apply_logical_matrix(cbind(...), "|", na.rm = na.rm)
}

#' @export
#' @rdname logic_ext
# nolint next: object_name_linter.
AND <- function(..., na.rm = FALSE) {
  apply_logical_matrix(cbind(...), "&", na.rm = na.rm)
}

#' @export
#' @rdname logic_ext
either <- function(x, y) {
  is_true(x) | is_true(y)
}

#' @export
#' @rdname logic_ext
is_boolean <- function(x) {
  is.logical(x) || (is.numeric(x) && !anyNA(match(x, c(NA, 0, 1))))
}

#' @export
#' @rdname logic_ext
# nolint next: object_name_linter.
none <- function(..., na.rm = FALSE) {
  !any(..., na.rm = na.rm)
}

#' @export
#' @rdname logic_ext
# nolint next: object_name_linter.
isNA <- function(x) {
  is.logical(x) && length(x) == 1L && is.na(x)
}

# FUNS --------------------------------------------------------------------

# nolint next: object_name_linter.
apply_logical_matrix <- function(mat, FUN, na.rm) {
  stopifnot(is.matrix(mat), is_boolean(mat))

  na_val <- if (na.rm) {
    switch(FUN, `|` = FALSE, `&` = TRUE)
  } else {
    NA
  }

  use_fun <- match.fun(FUN)

  apply(mat, 1L, function(x) {
    if (na.rm) {
      x <- remove_na(x)
    }

    switch(
      length(x) + 1L,
      na_val,
      x
    ) %||%
      Reduce(use_fun, x)
  })
}
